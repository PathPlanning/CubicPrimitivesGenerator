"""
Данный код реализует многомерный метод Ньютона для генерации примитива движения (оптимизации, подбора параметров траектории).

В общем виде работает это следующим образом: заводится экземпляр класса ShortTrajectory, в котором фиксируются желаемые
начальное start и целевое goal состояния, между которыми генерируем траекторию. При этих зафиксированных состояниях
траектория определяется ровно тремя параметрами k1, k2, log_length второй параметризации (так как kf уже фиксирован
в goal), которые нужно подобрать. Для этого имеется функция get_residual, которая возвращает три числовых значения
(трехмерный вектор) -- разность между компонентами x,y,theta желаемого целевого состояния goal и текущего (траектории с текущими
параметрами k1, k2, log_length, выходящей из состояния start) финального состояния final_state. Эти числа требуется занулить
(чем ближе они к нулю, тем точнее траектория идёт в goal), получив требуемую траекторию. Получается, что есть три параметра
k1, k2, log_length, которыми определяются три значения функции get_residual, которые необходимо занулить (всё это при фиксированных
start и goal). Это можно сделать многомерным метод Ньютона, который итеративно подберёт значения k1, k2, log_length, чтобы get_residual
был как можно ближе к 0.

Таким образом, можно генерировать короткую траекторию между фиксированными start и goal.
"""

import numpy as np
import sys
sys.path.append("../common/")
from PRIM_structs import *



def get_residual(traj: ShortTrajectory) -> np.ndarray:
    """
    Функция, которая вычисляет функцию невязки: покомпонентную разность между целевым состоянием goal
    и текущим концом траектории final_state. Генерация траектории заключается в попытке занулить эту функцию.
    
        traj: экземпляр ShortTrajectory, короткая траектория (параметры k1, k2, log_length которой подбираются при генерации).
    """
    
    final = traj.final_state()  # текущее финальное состояние
    return np.array([traj.goal.x - final.x,
                     traj.goal.y - final.y,
                     traj.goal.theta - final.theta])   # покомпонентная разница с целевым состоянием goal
                                                       # заметим, что учитываются только x,y,theta, так как кривизна kf в текущем финальном состоянии
                                                       # всегда равна кривизне в goal (так как kf является четвёртым параметром второй параметризации ->
                                                       # -> он при фиксированном goal тоже автоматически фиксирован -> удобно!)



def calc_Jacobian_matrix(traj: ShortTrajectory, params: np.ndarray, dk: float = 0.001, dl: float = 0.001) -> np.ndarray:
    """
    Функция вычисляет матрицу Якоби (3 на 3) для функции get_residual, рассматриваемой как функцию от параметров k1, k2, log_length
    короткой траектории (во второй параметризации). Её можно так рассматривать, ведь эти три параметра (при фиксированном начальном состоянии
    и фиксированной конечной кривизне goal.k) однозначно задают траекторию, а по траектории однозначно считается функция невязки.
    Функция get_residual трёхмерная (возвращаемый ею вектор невязки имеет длину 3) и количество параметров короткой
    траектории (во второй параметризации при фиксированном целевом состоянии) тоже три (k1, k2, log_length), поэтому матрица Якоби будет
    иметь размер 3 на 3 и состоять из частных производных компонентов функции невязки по этим параметрам траектории. Частные
    производные считаются численно (методом конечных разностей, регулируемом параметрами dk и dl).
    
        traj: траектория между фиксированными состояниями start, goal,
        params: вектор текущих значений параметров траектории k1, k2, log_length (в этой точке (при этих значениях параметров) считается матрица),
        dk, dl: небольшое приращение параметров (dk для k1,k2 и dl для log_length), чтобы численно подсчитать частные производные.
    """
    
    k1, k2, log_length = params  # текущие параметры
    traj = ShortTrajectory(traj.start, traj.goal)  # создаём копию (задавая те же состояния) траектории, чтобы не портить имеющуюся
    
    dF_p = get_residual(traj.set_curve_params(k1+dk, k2, log_length))  # считаем невязки при сдвинутом параметре k1
    dF_m = get_residual(traj.set_curve_params(k1-dk, k2, log_length))
    grad_k1 = (dF_p - dF_m) / (2 * dk)  # метод конечных разностей: поделив разницу компонент функции невязки на величину приращения параметра,
                                        # получаем приблизительное значение частных производных компонентов get_residual по k1

    dF_p = get_residual(traj.set_curve_params(k1, k2+dk, log_length))
    dF_m = get_residual(traj.set_curve_params(k1, k2-dk, log_length))
    grad_k2 = (dF_p - dF_m) / (2 * dk)  # аналогично -- частные производные компонентов get_residual по k2

    dF_p = get_residual(traj.set_curve_params(k1, k2, log_length+dl))
    dF_m = get_residual(traj.set_curve_params(k1, k2, log_length-dl))
    grad_S = (dF_p - dF_m) / (2 * dl)  # и по log_length

    return np.hstack((grad_k1.reshape(-1, 1), grad_k2.reshape(-1, 1), grad_S.reshape(-1, 1)))  # собираем все частные производные в матрицу Якоби 



def optimization_Newton(start: State, goal: State, iters: int = 2000, eps: float = 1e-2, lr: float = 0.03, redraw_trajectory = None) -> ShortTrajectory:
    """
    Функция многомерного метода Ньютона, которая подбирает параметры траектории.

        start, goal: состояния, между которыми хотим построить короткую допустимую траекторию,
        iters: число итераций метода Ньютона (число N_{max} в тексте статьи),
        eps: норма функции невязки, при достижении которой считаем, что траектория уже достаточно точно
             идёт в целевое состояние и останавливаем алгоритм,
        lr: коэффициент обучения, с которым происходит оптимизация (коэффициент alpha в тексте статьи),
        redraw_trajectory: можно передать функцию для онлайн-отображения процесса генерации траектории.
    """
    
    traj =  ShortTrajectory(start, goal)  # фиксируем траекторию между двумя состояниями
    params = np.array([0.0, 0.0, 0.0])    # начальные параметры траектории (во второй параметризации): k1, k2, log_length

    steps = 0
    for i in range(iters):
        steps += 1
        curr_diff = get_residual(traj.set_curve_params(*params))  # вычисляем текущую невязку: для этого устанавливаем текущие параметры в traj
        J = calc_Jacobian_matrix(traj, params)  # вычисляем матрицу Якоби в текущих параметрах params
        params -= lr * np.linalg.inv(J) @ curr_diff  # обновляем параметры многомерным методом Ньютона ->
                                                     # -> стремимся занулить невязку curr_diff

        if np.sum(curr_diff ** 2) ** 0.5 <= eps:  # если норма невязки достаточно мала, можно останавливать поиск
            break
        if redraw_trajectory:
            redraw_trajectory(traj, i)  # перерисовываем траекторию (передаём саму траекторию для рисования + номер итерации на всякий случай)

    else:
        print("Невозможно найти траекторию! Метод Ньютона не сошёлся!")
        return None

    return steps, traj.set_curve_params(*params)  # возвращаем найденную траекторию (с найденными параметрами)
