"""
В данном файле перечислены основные структуры данных, необходимые для генерации примитивов движения.
"""

import numpy as np
from scipy.integrate import quad
from typing_extensions import Self  # Self появился в typing только в 3.11 Питон... в ранних версиях используем typing_extensions



class State:
    """
    Класс для описания 4-ёх мерного состояния мобильного агента: координаты, угол направления, кривизна
    """
    
    def __init__(self, x: float, y: float, theta: float, k: float = 0.0) -> None:
        self.x = x
        self.y = y
        self.theta = theta
        self.k = k
    

      
class ShortTrajectory:
    """
    Класс для хранения и генерации короткой допустимой траектории между двумя состояниями. 
    
    Короткая траектория задаётся начальным состоянием start (откуда она выходит) и своими параметрами
    (есть две параметризации, как описано в тексте статьи). В рамках кода удобно также хранить целевое состояние goal,
    куда траектория в идеале (при подобранных параметрах) "должна была бы идти" - но реальное состояние, в котором она
    кончается получается функцией final_state.
    
    Задача построения короткой траектории (подбор параметров многомерным методом Ньютона) как раз заключается в том, чтобы
    подобрать параметры такие, чтобы final_state стал равен goal.
    
    Таким образом, этот класс используется следующим образом: сначала фиксируются конкретные начальное и целевое состояния.
    Далее запускается оптимизация, которая подбирает параметры, чтобы final_state стал равен goal.
    """
    
    
    def __init__(self, start: State, goal: State) -> None:
        """
        Инициализация.
        
            start: начальное состояние, из которого выходит траектория,
            goal: состояние, в которое "в идеале" должна идти траектория.
        """
        
        # фиксированные кончики траектории:
        self.start = start
        self.goal = goal
        self.k0 = self.start.k  # начальная кривизна
        
        # первая (базовая) параметризация короткой траектории: a, b, c - коэффициенты кривизны и длина:
        self.a = None
        self.b = None
        self.c = None
        self.length = None

        # вторая (предлагаемая) параметризация траектории: значения кривизны в трёх точках и логарифм длины:
        self.log_length = None
        self.k1 = None
        self.k2 = None
        self.kf = None

        # векторизуем функции получения координат (x,y) точки на траектории, чтобы можно было получать 
        # сразу набор координат по набору переменных s (точки на траектории):
        self.vect_x = np.vectorize(self.x)
        self.vect_y = np.vectorize(self.y)
        

    def set_coef_params(self, a: float, b: float, c: float, length: float) -> Self:
        """
        Фиксируем параметры короткой траектории с помощью первой (1) параметризации.
        
            a, b, c: параметры полиномиальной кривизны (определяют геометрию траектории),
            length: длина траектории.
        """
        
        assert length >= 0, "Длина не может быть отрицательна!"  # длина всегда неотрицательна
        
        # устанавливаем параметры первой параметризации:
        self.length = length  
        self.a = a
        self.b = b
        self.c = c
        
        # вычисляем параметры второй:
        self.log_length = np.log(length)
        self.k1 = self.k(1/3 * length)
        self.k2 = self.k(2/3 * length)
        self.kf = self.goal.k  # удобство второй параметризации в том, что один параметр - конечная кривизна - сразу однозначно задан из goal 

        return self
        

    def set_curve_params(self, k1: float, k2: float, log_length: float) -> Self:
        """
        Фиксируем параметры через вторую (2) параметризацию.
        
            k1, k2: значения кривизны в двух точках,
            log_length: логарифм длины кривизны.
        """
        
        # устанавливаем параметры второй параметризации:
        self.log_length = log_length
        self.k1 = k1
        self.k2 = k2
        self.kf = self.goal.k
        
        # вычисляем параметры первой параметризации:
        self.length = np.exp(log_length)
        vect_s = np.array([0, 1/3 * self.length, 2/3 * self.length, self.length]).reshape(-1, 1)
        mat_s = np.hstack((vect_s ** 0, vect_s ** 1, vect_s ** 2, vect_s ** 3))  # получаем матрицу
        params = np.linalg.inv(mat_s) @ np.array([self.k0, self.k1, self.k2, self.kf])  # делаем переход от второй параметризации к первой
        k0, a, b, c = params
        self.a, self.b, self.c = a, b, c  # устанавливаем параметры
        assert k0 == self.k0, "Что-то не так, кривизна k0 не меняется сменой параметризации!"  # проверяем, что всё корректно: полученное k0 - тот же самый, что был до этого в первой параметризации
                                                                                               # (это просто одна и та же переменная, которая для удобства участвует в смене параметризации, но сама не меняется)
        return self


    """
    При фиксированном начальном состоянии start, а также фиксированных параметрах первой параметризации, 
    однозначно определяются функции, задающие короткую траекторию. Все эти функции зависят от s - точки на кривой
    (s = длина пройденного кусочка от начала кривой) и имеют вид (подробнее - см. текст статьи): 
        кривизна - полиномиальная функция, 
        угол направления - полином 4 степени,
        координаты x и y - интегралы от cos и sin угла направления.
    
    Следующие четыре метода по точке s получают значения этих функций в ней: кривизна, угол направления, координаты.
    """
    
    
    def k(self, s: float) -> float:
        """
        Получение значения кривизны в точке s.
            s: точка на траектории 
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"  # длина пройденного куска неотрицательна
        return self.k0 + self.a * s + self.b * s**2 + self.c * s**3  # считаем значение полиномиальной кривизны
    
    
    def theta(self, s: float) -> float:
        """
        Получение значения угла направления в точке s.
            s: точка на траектории
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"
        theta0, k0 = self.start.theta, self.k0
        a, b, c = self.a, self.b, self.c
        return theta0 + k0 * s + a/2 * s**2 + b/3 * s**3 + c/4 * s**4  # используем уравнения угла направления


    def x(self, s: float) -> float:
        """
        Получение координаты x в точке s.
            s: точка на траектории
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"
        x0 = self.start.x
        return x0 + quad(lambda x: np.cos(self.theta(x)), 0, s, limit=200, limlst=10)[0]  # вычисляем интеграл численно
    
    
    def y(self, s: float) -> float:
        """
        Получение координаты y в точке s.
            s: точка на траектории
        """
        
        assert s >= 0, "Параметр s должен быть неотрицателен!"
        y0 = self.start.y
        return y0 + quad(lambda x: np.sin(self.theta(x)), 0, s, limit=200, limlst=10)[0]


    # семплирование координат x и y на траектории с шагом (расстояние между соседними точками) ds:
    def sample_x(self, ds: float = 0.02) -> np.ndarray:
        num = int(self.length / ds)
        return self.vect_x(np.linspace(0, self.length, num=num, endpoint=True))  # endpoint=True, чтобы конечная точка (координаты финального состояния) тоже была
    
    def sample_y(self, ds: float = 0.02) -> np.ndarray:
        num = int(self.length / ds)
        return self.vect_y(np.linspace(0, self.length, num=num, endpoint=True))  # т.к. функции x и y векторизованы, можем сразу набор (np.ndarray) координат считать по множеству точек s


    def state(self, s: float) -> State:
        """
        Функция для получения состояния мобильного агента, находящегося в точке s (= на удалении s от старта) траектории. 
        
            s: точка на траектории
        
        Замечание: Вообще траектория определяется как функция изменения состояния агента, поэтому здесь получаем фактически её значение
        в точке s. Координаты же (x,y) это положение на траектории, рассматриваемой как кривая в рабочем пространстве (и получающаяся
        проекцией исходной функции состояния на плоскость карты). Это означает, что если нарисовать эту кривую (например, просто отметив
        много-много точек (x,y) с маленьким шагом - что делает функция sample_x и sample_y), то при движении по ней у мобильного агента
        будет меняться состояние согласно траектории (то есть координаты будут меняться как x(s),y(s) (но это и так ясно - мы так
        кривую из этих точек нарисовали), угол направления будет изменяться как theta(s) (а угол направления = угол между касательной
        к кривой и осью абсцисс), кривизна изменится как k(s)) - просто потому, что эта кривая является проекцией траектории.
        """
        
        return State(self.x(s), self.y(s), self.theta(s), self.k(s))  # собираем состояние в точке s из компонент: координат, угла направления и кривизны
                                                                      # (проекцией этого состояния на плоскость рабочего пространства будет просто пара точек x(s),y(s))


    def final_state(self) -> State:
        """
        Функция для получения состояния, в котором заканчивается короткая траектория, выходящая из start
        и имеющая заданные параметры.
        
        Цель оптимизации (подбора параметров) в том, чтобы goal = final_state
        """
        
        return self.state(self.length)
